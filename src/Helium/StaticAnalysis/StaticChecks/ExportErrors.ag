-----------------------------------------------------------------------------
-- |The Helium Compiler : Static Analysis
-- 
-- Maintainer  :  bastiaan@cs.uu.nl
-- Stability   :  experimental
-- Portability :  unknown
--
--
-------------------------------------------------------------------------------

--The double declarations/type constructors are added, because we don't want extra errors for these.
SEM Module
  | Module  exports . namesInScope    = @scopeNoConflicts ++ map head @declDouble
                    . ambiguousNames  = @ambiguousConflicts
                    . modulesInScope  = (@moduleName : @fileName : @body.importedModules)
                    . tyconsInScope   = map fst @uniqueTypeConstructors ++ map head @duplicatedTypeConstructors
                    . ambiguousTyCons = @ambiguousTypeConstructors
                    . consInScope     = @valueConstructorsWithParents
                    . allConsInScope  = @valueConstructorsWithParents ++ concat @ambiguousValueConstructorsWithParents
                    . duplicatedCons  = @duplicatedValueConstructors
                    . ambiguousCons   = @ambiguousValueConstructors

SEM Module 
  | Module    loc . exportErrors = let importErrors = @body.importErrors
                                       firstErrors = @exports.exportErrors 
                                   in case importErrors of
                                        [] -> case firstErrors of
                                                [] -> @exportNameClashes 
                                                er -> er
                                        err -> err
              loc . modulename = maybe (nameFromString "Main") id @name.name
              loc . exportModuleScope = [(@modulename, @declNoConflicts 
                                                        ++ map fst @declNoConflictsTyCon
                                                        ++ map fst @declNoConflictsValCon)] 
                                            ++ getModuleList @lhs.importEnvironmentsWithMod
              loc . exportNameClashes = (map ExportConflict . getConflicts.mergeSameOrigins) (@exports.totalExports)
              body . modDecls = map (\(mod,_,decls) -> (mod, decls)) @lhs.importEnvironmentsWithMod
              
                    
ATTR MaybeExports Exports Export
    [ namesInScope      : Names
      ambiguousNames    : { [[Name]] }
      modulesInScope    : Names
      tyconsInScope     : Names
      ambiguousTyCons   : { [[Name]] }
      consInScope       : { [(Name, Name)] }
      allConsInScope    : { [(Name, Name)] }
      duplicatedCons    : { [[Name]] }
      ambiguousCons     : { [[Name]] }
      exportModuleScope : { [(Name, Names)] }
    |
    | exportErrors USE { ++ } { [] } : { [Error] }
      exportList   USE { ++ } { [] } : { [(Name, String)] }
      totalExports USE { ++ } { [] } : { [(Name, (Name,String))] }
    ]                    
    
{

checkExport :: Entity -> Name -> [Name] -> [[Name]]-> [Error]
checkExport entity name inScope ambiguous = ambiguousOrUndefinedErrors entity name inScope ambiguous []


checkConstructorExport :: Entity -> (Name, Name) -> [(Name, Name)] -> [[Name]] -> [[Name]] -> [Error]
checkConstructorExport entity (constructor, parent) inScopePairs duplicated ambiguous =
    case lookup constructor inScopePairs of
        Just realparent  -> if parent == realparent then 
                                []
                            else
                                [ExportWrongParent entity constructor parent realparent [child | (child, par) <- inScopePairs, par == parent ]]
        Nothing          -> if constructor `elem` map head duplicated then
                                []
                            else
                                ambiguousOrUndefinedErrors entity constructor (map fst inScopePairs) ambiguous []

getModuleList :: [(Name, ImportEnvironment, ModuleDecls)] -> [(Name, Names)]
getModuleList = map getNames
    where
        getNames (mod,env, _) = (mod,
            (M.keys . typeEnvironment  ) env ++
            (M.keys . typeConstructors )  env ++
            (M.keys . valueConstructors)  env
            )

setTotal :: Name -> Names -> String-> [(Name, (Name, String))]
setTotal export inScope exportString = [(decl, (export, exportString)) | decl <- inScope, decl == export]

setTotalCons :: Name -> [(Name, Name)] -> String -> [(Name, (Name, String))]
setTotalCons exportPar inScopePairs exportString = [(child, (exportPar, exportString)) | (child, par) <- inScopePairs, par == exportPar ]

getConflicts :: [(Name, a)] -> [[(Name, a)]]
getConflicts = let comp (x,_) (y,_) = compare x y
                   eq   (x,_) (y,_) = x == y
                   predicate xs = length xs > 1
               in filter predicate
                . groupBy eq 
                . sortBy comp
}


ATTR MaybeNames [ | | toList USE { ++ } { [] } : Names ]

SEM MaybeNames
    | Nothing lhs.toList = []
    | Just    lhs.toList = @names.self

-- If classes are added, this should be updated aswell
SEM Export
    | Variable    lhs . exportErrors =  checkExport ExportVariable @name.self @lhs.namesInScope @lhs.ambiguousNames
                  lhs . totalExports = setTotal @name.self @lhs.namesInScope (show @name.self)
    | TypeOrClassComplete
                  lhs . exportErrors =  checkExport ExportTypeConstructorOrClass @name.self @lhs.tyconsInScope @lhs.ambiguousTyCons
                  lhs . totalExports = setTotal @name.self @lhs.tyconsInScope @showExp ++ setTotalCons @name.self @lhs.allConsInScope @showExp
                  loc . showExp      = (show @name.self) ++ "(..)"
    | TypeOrClass lhs . exportErrors =  checkExport ExportTypeConstructorOrClass @name.self
                                           @lhs.tyconsInScope @lhs.ambiguousTyCons
                                            ++
                                            concatMap
                                                (\name ->
                                                    checkConstructorExport ExportConstructor (name, @name.self) 
                                                        @lhs.consInScope @lhs.duplicatedCons @lhs.ambiguousCons
                                                )
                                                @names.toList
                  lhs . totalExports = setTotal @name.self @lhs.tyconsInScope @showExp ++ concatMap (\n -> setTotal n (map fst @lhs.consInScope) @showExp) @names.toList
                  loc . showExp      = (show @name.self) ++ "(" ++ intercalate "," (map show @names.toList) ++ ")"
    | Module      lhs . exportErrors =  checkExport ExportModule @name.self
                                           @lhs.modulesInScope []
                  lhs . totalExports = [(decl, (@name.self, @showExp)) | (mod, decls) <- @lhs.exportModuleScope, mod == @name.self, decl <- decls]
                  loc . showExp      = "module " ++ show @name.self
-------------------------------------------
-- Collecting the imported modules

ATTR ImportDeclarations ImportDeclaration  [ | importedModules : Names | ]
ATTR Body                                  [ | | importedModules : Names ]  

SEM Body
  | Hole    lhs . importedModules = []
  | Body    importdeclarations . importedModules = []
    
SEM ImportDeclaration
  | Import   lhs . importedModules = @name.self : @lhs.importedModules


-------------------------------------------
-- Collecting import specification errors

ATTR Body ImportDeclarations ImportDeclaration MaybeImportSpecification
     ImportSpecification Imports Import
     [ modDecls : { [(Name, ModuleDecls)] } | | importErrors USE { ++ } { [] } : { [Error] } ]

ATTR MaybeImportSpecification ImportSpecification Imports Import [theModule : Name | | ]

SEM ImportDeclaration 
    | Import importspecification.theModule = @name.self

SEM ImportSpecification
    | Import lhs.importErrors = if @hiding then [] else @imports.importErrors

SEM Import
    | Variable                lhs.importErrors = checkImportListVal @lhs.modDecls @lhs.theModule @name.self
    | TypeOrClass             lhs.importErrors = checkImportListTyCon @lhs.modDecls @lhs.theModule @name.self
                                                  ++ concatMap (checkImportListValCon @lhs.modDecls @lhs.theModule @name.self) @names.toList
    | TypeOrClassComplete     lhs.importErrors = checkImportListTyCon @lhs.modDecls @lhs.theModule @name.self

{
checkImportListVal :: [(Name, ModuleDecls)] -> Name -> Name -> [Error]
checkImportListVal modDecls mod name = case lookup mod modDecls of
    Nothing -> internalError "StaticChecks.ag" "checkImportListVal" ("couldn't find module " ++ show mod ++ " in our lookup list")
    Just (values, _, _) -> if name `elem` values then []
                            else [ NotExportedByModule name mod values ]

checkImportListTyCon :: [(Name, ModuleDecls)] -> Name -> Name -> [Error]
checkImportListTyCon modDecls mod name = case lookup mod modDecls of
    Nothing -> internalError "StaticChecks.ag" "checkImportListVal" ("couldn't find module " ++ show mod ++ " in our lookup list")
    Just (_, tycons, _) -> if name `elem` tycons then []
                            else [ NotExportedByModule name mod tycons ]


checkImportListValCon :: [(Name, ModuleDecls)] -> Name -> Name -> Name -> [Error]
checkImportListValCon modDecls mod parent name = case lookup mod modDecls of
    Nothing -> internalError "StaticChecks.ag" "checkImportListVal" ("couldn't find module " ++ show mod ++ " in our lookup list")
    Just (_, _, valcons) -> if (name, parent) `elem` valcons then []
                            else case lookup name valcons of
                                    Nothing -> [ NotExportedByModule name mod (map fst valcons) ]
                                    Just realparent -> [ExportWrongParent ImportConstructor name parent realparent [child | (child, par) <- valcons, par == parent] ]            
}